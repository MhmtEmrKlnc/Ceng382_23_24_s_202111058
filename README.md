**Explanation of why Lab 6 which I made last week does not provide SRP and DI principles and what these principles do for the 7th question of Lab 7.**
In SRP, a class should cover a single responsibility or task so that code changes can be made more easily and classes are more focused. The ReservationHandler class I wrote in Lab 6 takes on the responsibilities of AddReservation, DeleteReservation and DisplayWeeklySchedule. This might appear convenient initially, but it creates coupling between unrelated functionalities. AddReservation and DeleteReservation are closely related to each other, but we cannot say the same for DisplayWeeklySchedule. As the application evolves, changes in one area could inadvertently impact the other, resulting in tangled and hard-to-maintain code. That's why we need to create separate classes for each separate responsibility. By isolating each responsibility, we prevent a class from becoming bloated and ensure that changes in one area don't affect unrelated parts. Thus, we increase code readability and understandability. In other words, we can create a separate class called Display and write the DisplayWeeklySchedule method in it. Thus, the ReservationHandler class only deals with reservation management, while the Display class only performs the display function. In this way, we can write codes that are more testable, easier to change and maintain, and where changes affect each other less.

DI promotes loose coupling by allowing dependencies to be injected from outside. Creating a Room with new in the Reservation class breaks the DI. Instead, a room should have been sent to the constructor and this.room=room could have been made. Likewise, in the ReservationHandler class, I create Reservation[][] reservations with new, which is against the DI principle because I do not inject the reservations dependency from outside. Instead, here I can change the constructor to public ReservationHandler(Reservation[][] reservations) and make this.reservations= reservations inside the constructor so that the class receives a reservation array from outside. This way, the reservations array is outsourced and the ReservationHandler class becomes more flexible. For example, we can create different ReservationHandler instances that work with different reservation data.
